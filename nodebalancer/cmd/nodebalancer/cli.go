package main

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/urfave/cli/v2"
)

var CommonCommands = []*cli.Command{
	{
		Name:  "access",
		Usage: "Operations with access IDs as Brood resource",
		Flags: []cli.Flag{},
		Subcommands: []*cli.Command{
			{
				Name:  "add",
				Usage: "Add new user's access ID",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:     "access-token",
						Aliases:  []string{"t"},
						Usage:    "Authorized user access token with granted privileges to create resources in Moonstream Bugout application and sharing read permissions to nodebalancer application user",
						Required: true,
					},
					&cli.StringFlag{
						Name:     "access-id",
						Aliases:  []string{"a"},
						Usage:    "UUID for access identification",
						Required: true,
					},
					&cli.StringFlag{
						Name:     "user-id",
						Aliases:  []string{"u"},
						Usage:    "Bugout user ID",
						Required: true,
					},
					&cli.StringFlag{
						Name:     "name",
						Aliases:  []string{"n"},
						Usage:    "Name of the user or application to work with nodebalancer",
						Required: true,
					},
					&cli.StringFlag{
						Name:    "description",
						Aliases: []string{"d"},
					},
					&cli.BoolFlag{
						Name:    "blockchain-access",
						Aliases: []string{"b"},
						Usage:   "Specify this flag to grant direct access to blockchain nodes",
					},
					&cli.BoolFlag{
						Name:    "extended-methods",
						Aliases: []string{"e"},
						Usage:   "Specify this flag to grant execution availability to not whitelisted methods",
					},
					&cli.UintFlag{
						Name:    "period-duration",
						Aliases: []string{"p"},
						Usage:   "Access period duration in seconds",
						Value:   2592000,
					},
					&cli.UintFlag{
						Name:    "max-calls-per-period",
						Aliases: []string{"m"},
						Usage:   "Max available calls to node during the period",
						Value:   10000,
					},
				},
				Before: func(c *cli.Context) error {
					periodDurationFlag := c.Uint("period-duration")

					if periodDurationFlag < 3600 {
						return fmt.Errorf("time for --period-duration should be greater then 1 hour")
					}

					return nil
				},
				Action: func(c *cli.Context) error {
					var clientErr error
					bugoutClient, clientErr = CreateBugoutClient()
					if clientErr != nil {
						return fmt.Errorf("an error occurred during Bugout client creation, err: %v", clientErr)
					}

					newAccess, newErr := AddNewAccess(c.String("access-id"), c.String("user-id"), c.String("name"), c.String("description"), c.Bool("blockchain-access"), c.Bool("extended-methods"), c.Uint("period-duration"), c.Uint("max-calls-per-period"), c.String("access-token"))
					if newErr != nil {
						return fmt.Errorf("failed to add new access, err: %v", newErr)
					}

					_, shareErr := ShareAccess(newAccess.ResourceID, NB_CONTROLLER_USER_ID, "user", DEFAULT_AUTOGENERATED_USER_PERMISSIONS, c.String("access-token"))
					if shareErr != nil {
						return fmt.Errorf("failed to share access to resource ID %s with nodebalancer application user, err: %v", newAccess.ResourceID, shareErr)
					}

					newAccessJson, err := json.Marshal(newAccess)
					if err != nil {
						return fmt.Errorf("unable to encode resource %s data interface to json, err: %v", newAccess.ResourceID, err)
					}
					fmt.Println(string(newAccessJson))

					return nil
				},
			},
			{
				Name:   "update",
				Usage:  "Update user's access ID",
				Flags:  []cli.Flag{},
				Before: func(c *cli.Context) error { return nil },
				Action: func(c *cli.Context) error { return nil },
			},
			{
				Name:  "delete",
				Usage: "Delete user's access ID",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:     "access-token",
						Aliases:  []string{"t"},
						Usage:    "Authorized user access token with granted privileges to delete resources in Moonstream Bugout application",
						Required: true,
					},
					&cli.StringFlag{
						Name:    "access-id",
						Aliases: []string{"a"},
						Usage:   "UUID for access identification",
					},
					&cli.StringFlag{
						Name:    "user-id",
						Aliases: []string{"u"},
						Usage:   "Filter by user_id",
					},
				},
				Before: func(c *cli.Context) error {
					accessIdFlag := c.String("access-id")
					userIdFlag := c.String("user-id")

					if accessIdFlag == "" && userIdFlag == "" {
						return fmt.Errorf("at least one of --access-id or --user-id should be set")
					}

					return nil
				},
				Action: func(c *cli.Context) error {
					var clientErr error
					bugoutClient, clientErr = CreateBugoutClient()
					if clientErr != nil {
						return fmt.Errorf("an error occurred during Bugout client creation: %v", clientErr)
					}

					resources, getResErr := GetAccesses(c.String("access-id"), c.String("user-id"), c.String("access-token"))
					if getResErr != nil {
						return fmt.Errorf("unable to get Bugout resources, err: %v", getResErr)
					}

					if len(resources.Resources) == 0 {
						fmt.Println("[]")
						return nil
					}

					var clientAccesses []ClientAccess
					for _, resource := range resources.Resources {
						clientAccess, parseErr := ParseResourceDataToClientAccess(resource)
						if parseErr != nil {
							fmt.Printf("Unable to parse resource data, err: %v", parseErr)
							continue
						}

						clientAccesses = append(clientAccesses, *clientAccess)
					}

					for _, access := range clientAccesses {
						fmt.Printf("Deleting resource ID %s with name %s in 3 seconds..\n", access.ResourceID, access.ClientResourceData.Name)
						time.Sleep(3 * time.Second)

						_, delErr := DeleteAccess(access.ResourceID, c.String("access-token"))
						if delErr != nil {
							fmt.Printf("Failed to delete resource with ID %s err: %v\n", access.ResourceID, delErr)
							continue
						}
					}

					return nil
				},
			},
			{
				Name:  "list",
				Usage: "List all user access IDs",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:     "access-token",
						Aliases:  []string{"t"},
						Usage:    "Authorized user access token with granted privileges to get resources in Moonstream Bugout application",
						Required: true,
					},
					&cli.StringFlag{
						Name:    "access-id",
						Aliases: []string{"a"},
						Usage:   "Filter by access_id",
					},
					&cli.StringFlag{
						Name:    "user-id",
						Aliases: []string{"u"},
						Usage:   "Filter by user_id",
					},
				},
				Action: func(c *cli.Context) error {
					var clientErr error
					bugoutClient, clientErr = CreateBugoutClient()
					if clientErr != nil {
						return fmt.Errorf("an error occurred during Bugout client creation: %v", clientErr)
					}

					resources, getResErr := GetAccesses(c.String("access-id"), c.String("user-id"), c.String("access-token"))
					if getResErr != nil {
						return fmt.Errorf("unable to get Bugout resources, err: %v", getResErr)
					}

					var clientAccesses []ClientAccess
					for _, resource := range resources.Resources {
						clientAccess, parseErr := ParseResourceDataToClientAccess(resource)
						if parseErr != nil {
							fmt.Printf("Unable to parse resource data, err: %v", parseErr)
							continue
						}

						clientAccesses = append(clientAccesses, *clientAccess)
					}

					userAccessesJson, marErr := json.Marshal(clientAccesses)
					if marErr != nil {
						return fmt.Errorf("unable to marshal user accesses struct, err: %v", marErr)
					}
					fmt.Println(string(userAccessesJson))

					return nil
				},
			},
		},
	},
	{
		Name:  "configure",
		Usage: "Generate nodebalancer configuration",
		Action: func(cCtx *cli.Context) error {

			return nil
		},
	},
	{
		Name:  "server",
		Usage: "Start nodebalancer server",
		Action: func(cCtx *cli.Context) error {

			return nil
		},
	},
	{
		Name:  "version",
		Usage: "Shows nodebalancer package version",
		Action: func(cCtx *cli.Context) error {
			fmt.Println(NB_VERSION)
			return nil
		},
	},
}

func NodebalancerAppCli() *cli.App {
	return &cli.App{
		Name:                 "nodebalancer",
		Version:              fmt.Sprintf("v%s", NB_VERSION),
		Usage:                "Web3 node balancer",
		EnableBashCompletion: true,
		Commands:             CommonCommands,
	}
}
